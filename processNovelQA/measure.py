'''

文件checking_inputs.json中的数据是由此文件产生
环境要求：
RAGFLOW，Xinference，RAGChecker，RefChecker

'''
from api.db.services.knowledgebase_service import KnowledgebaseService
import json
import logging
import matplotlib
matplotlib.use('Agg')
import os
from pathlib import Path
import requests
import warnings
warnings.filterwarnings("ignore", category=UserWarning, module="pydantic")

class EnvSetup:
    def __init__(self, testtenant, password, kb_name, tenant_id) -> None:
        self.rooturl = 'http://localhost:9225/'
        self.testtenant = testtenant
        self.password = password
        self.kb_name= kb_name
        self.tenant_id = tenant_id

    def userlogin(self):
        login_url = self.rooturl + 'v1/user/login'  # 登录页 URL（根据实际路径调整）
        login_data = {
            'email': self.testtenant,  # 登录所需的用户名
            'password': self.password  # 登录所需的密码
        }
        session = requests.Session()
        login_response = session.post(login_url, json=login_data)

        if login_response.status_code == 200:
            logging.warning("Login success!")
        else:
            logging.warning("Fail to login!")
            return None

        session.headers.update({
            'Authorization': login_response.headers["Authorization"]
        })
        return session

    def formatdata(self, query_id, query, gt_answer, r_answer, chunks):
        """
        {
            "results": [
                {
                  "query_id": "<query id>", # string
                  "query": "<input query>", # string
                  "gt_answer": "<ground truth answer>", # string
                  "response": "<response generated by the RAG generator>", # string
                  "retrieved_context": [ # a list of retrieved chunks by the retriever
                    {
                      "doc_doc_idid": "<doc id>", # string, optional
                      "text": "<content of the chunk>" # string
                    },
                    ...
                  ]
                },
                ...
            ]
        }
        """
        query_data = {
            "query_id": query_id, # string
            "query": query, # string
            "gt_answer": gt_answer, # string
            "response": r_answer, # string
            "retrieved_context": [] #list
        }

        retrieved_context = []
        for chunk in chunks:
            retrieved_context_element = {
                "doc_id": chunk['doc_id'],
                "text": chunk['content_ltks']
            }
            retrieved_context.append(retrieved_context_element)

        query_data['retrieved_context'] = retrieved_context
        checking_inputs_file = 'checking_inputs.json'
        with open(checking_inputs_file, 'a+') as file:
            file.seek(0, 2)
            # 读取文件最后部分并判断是否需要加逗号
            if file.tell() > 0:
                file.seek(file.tell() - 1)  # 回到文件末尾的前一个字符
                last_char = file.read(1)
                if last_char == "}":
                    file.write(",\n")
            # 添加新的 JSON 对象
            json.dump(query_data, file)

if __name__ == "__main__":
    #LLM Env set
    envSetup = EnvSetup("test@163.com", "password", "PerformanceTestBase", "016a313cd22711ef93f30242ac110002") #使用前，请修改参数
    session = envSetup.userlogin()
    #Check knowledgebase existed or not
    KnowledgebaseService.get_by_name(envSetup.kb_name, envSetup.tenant_id)
    try:
        e, kb = KnowledgebaseService.get_by_name(envSetup.kb_name, envSetup.tenant_id)
        if not e:
            logging.warning("Fail to get knowledgeBase with name %s", envSetup.kb_name)
        else:
            kb_id = kb.id
    except Exception as e:
        logging.error(e)

    #Get Query/Set Query
    project_root = Path(__file__).resolve().parent
    queryFilePath = project_root / "novelqa_queries.json"

    with open(queryFilePath, "r", encoding="utf-8") as f:
        data = json.load(f)
        queries = data["input_data"]
        ## Json structure
        # "query_id": "20",
        # "query": "Why doesn't Raskolnikov want to meet his landlady?",
        # "gt_answer": "Raskolnikov doesn't want to meet his landlady because he owes her money and is hopelessly in debt to her, which makes him afraid of encountering her.",
        # "novel": "Crime And Punishment"
        ##

    #Get generated result
    conversation_ask_url = envSetup.rooturl + 'v1/conversation/ask'
    for query_json in queries:
        query_id = query_json['query_id']
        query = query_json['query']
        gt_answer = query_json['gt_answer']
        document_name = query_json['novel']

        conversation_ask_request_data = {
            "kb_ids": [envSetup.kb_id],
            "question": query
        }
        search_ask_response = session.post(conversation_ask_url, json=conversation_ask_request_data)
        if search_ask_response.status_code == 200:
            logging.info("Success fetch ask result for query %s",query)
        else:
            logging.warning("Fail to fetch ask result for query %s, status code: %s, response text: %s", query, search_ask_response.status_code, search_ask_response.text)

        search_ask_response_json = ""
        for line in search_ask_response.iter_lines():
            if line:
                line_str = line.decode("utf-8").split('data:', 1)[1]
                line_dict = json.loads(line_str)
                if line_dict['data'] == True:
                    break
                search_ask_response_json = line_dict['data']

        envSetup.formatdata(query_id, query, gt_answer, search_ask_response_json['answer'], search_ask_response_json['reference']['chunks'])




